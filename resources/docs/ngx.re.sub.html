<p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.sub(subject, regex, replace, options?)</em></p><p><strong>context:</strong> <em>init_worker_by_lua&#42;, set_by_lua&#42;, rewrite_by_lua&#42;, access_by_lua&#42;, content_by_lua&#42;, header_filter_by_lua&#42;, body_filter_by_lua&#42;, log_by_lua&#42;, ngx.timer.&#42;, balancer_by_lua&#42;, ssl_certificate_by_lua&#42;</em></p><p>Substitutes the first match of the Perl compatible regular expression <code>regex</code> on the <code>subject</code> argument string with the string or function argument <code>replace</code>. The optional <code>options</code> argument has exactly the same meaning as in <a href="#ngxrematch">ngx.re.match</a>.</p><p>This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the <code>&lt;replace&gt;</code> string argument, it will return <code>nil</code> and a string describing the error.</p><p>When the <code>replace</code> is a string, then it is treated as a special template for string replacement. For example,</p><p>```lua</p><p>local newstr, n, err = ngx.re.sub("hello, 1234", "([0-9])[0-9]", "[$0][$1]")  if newstr then  -- newstr == "hello, [12][1]34"  -- n == 1  else  ngx.log(ngx.ERR, "error: ", err)  return  end ```</p><p>where <code>$0</code> referring to the whole substring matched by the pattern and <code>$1</code> referring to the first parenthesized capturing substring.</p><p>Curly braces can also be used to disambiguate variable names from the background string literals: </p><p>```lua</p><p>local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "${0}00")  -- newstr == "hello, 100234"  -- n == 1 ```</p><p>Literal dollar sign characters (<code>$</code>) in the <code>replace</code> string argument can be escaped by another dollar sign, for instance,</p><p>```lua</p><p>local newstr, n, err = ngx.re.sub("hello, 1234", "[0-9]", "$$")  -- newstr == "hello, $234"  -- n == 1 ```</p><p>Do not use backlashes to escape dollar signs; it will not work as expected.</p><p>When the <code>replace</code> argument is of type "function", then it will be invoked with the "match table" as the argument to generate the replace string literal for substitution. The "match table" fed into the <code>replace</code> function is exactly the same as the return value of <a href="#ngxrematch">ngx.re.match</a>. Here is an example:</p><p>```lua</p><p>local func = function (m)  return "[" .. m[0] .. "][" .. m[1] .. "]"  end  local newstr, n, err = ngx.re.sub("hello, 1234", "( [0-9] ) [0-9]", func, "x")  -- newstr == "hello, [12][1]34"  -- n == 1 ```</p><p>The dollar sign characters in the return value of the <code>replace</code> function argument are not special at all.</p><p>This method requires the PCRE library enabled in Nginx. (<a href="#special-escaping-sequences">Known Issue With Special Escaping Sequences</a>).</p><p>This feature was first introduced in the <code>v0.2.1rc13</code> release.</p>