<p><strong>syntax:</strong> <em>ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)</em></p><p><strong>context:</strong> <em>init_worker_by_lua&#42;, set_by_lua&#42;, rewrite_by_lua&#42;, access_by_lua&#42;, content_by_lua&#42;, header_filter_by_lua&#42;, body_filter_by_lua&#42;, log_by_lua&#42;, ngx.timer.&#42;, balancer_by_lua&#42;, ssl_certificate_by_lua&#42;</em></p><p>Creates an Nginx timer with a user callback function as well as optional user arguments.</p><p>The first argument, <code>delay</code>, specifies the delay for the timer, in seconds. One can specify fractional seconds like <code>0.001</code> to mean 1 millisecond here. <code>0</code> delay can also be specified, in which case the timer will immediately expire when the current handler yields execution.</p><p>The second argument, <code>callback</code>, can be any Lua function, which will be invoked later in a background "light thread" after the delay specified. The user callback will be called automatically by the Nginx core with the arguments <code>premature</code>, <code>user_arg1</code>, <code>user_arg2</code>, and etc, where the <code>premature</code> argument takes a boolean value indicating whether it is a premature timer expiration or not, and <code>user_arg1</code>, <code>user_arg2</code>, and etc, are those (extra) user arguments specified when calling <code>ngx.timer.at</code> as the remaining arguments.</p><p>Premature timer expiration happens when the Nginx worker process is trying to shut down, as in an Nginx configuration reload triggered by the <code>HUP</code> signal or in an Nginx server shutdown. When the Nginx worker is trying to shut down, one can no longer call <code>ngx.timer.at</code> to create new timers with nonzero delays and in that case <code>ngx.timer.at</code> will return <code>nil</code> and a string describing the error, that is, "process exiting".</p><p>Starting from the <code>v0.9.3</code> release, it is allowed to create zero-delay timers even when the Nginx worker process starts shutting down.</p><p>When a timer expires, the user Lua code in the timer callback is running in a "light thread" detached completely from the original request creating the timer. So objects with the same lifetime as the request creating them, like <a href="#ngxsockettcp">cosockets</a>, cannot be shared between the original request and the timer user callback function.</p><p>Here is a simple example:</p><p>```nginx</p><p>location / {  ...  log_by_lua '  local function push_data(premature, uri, args, status)  -- push the data uri, args, and status to the remote  -- via ngx.socket.tcp or ngx.socket.udp  -- (one may want to buffer the data in Lua a bit to  -- save I/O operations)  end  local ok, err = ngx.timer.at(0, push_data,  ngx.var.uri, ngx.var.args, ngx.header.status)  if not ok then  ngx.log(ngx.ERR, "failed to create timer: ", err)  return  end  ';  } ```</p><p>One can also create infinite re-occuring timers, for instance, a timer getting triggered every <code>5</code> seconds, by calling <code>ngx.timer.at</code> recursively in the timer callback function. Here is such an example,</p><p>```lua</p><p>local delay = 5  local handler  handler = function (premature)  -- do some routine job in Lua just like a cron job  if premature then  return  end  local ok, err = ngx.timer.at(delay, handler)  if not ok then  ngx.log(ngx.ERR, "failed to create the timer: ", err)  return  end  end</p><p>local ok, err = ngx.timer.at(delay, handler)  if not ok then  ngx.log(ngx.ERR, "failed to create the timer: ", err)  return  end ```</p><p>Because timer callbacks run in the background and their running time will not add to any client request's response time, they can easily accumulate in the server and exhaust system resources due to either Lua programming mistakes or just too much client traffic. To prevent extreme consequences like crashing the Nginx server, there are built-in limitations on both the number of "pending timers" and the number of "running timers" in an Nginx worker process. The "pending timers" here mean timers that have not yet been expired and "running timers" are those whose user callbacks are currently running.</p><p>The maximal number of pending timers allowed in an Nginx worker is constrolled by the <a href="#lua_max_pending_timers">lua_max_pending_timers</a> directive. The maximal number of running timers is controlled by the <a href="#lua_max_running_timers">lua_max_running_timers</a> directive.</p><p>According to the current implementation, each "running timer" will take one (fake) connection record from the global connection record list configured by the standard <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections">worker_connections</a> directive in <code>nginx.conf</code>. So ensure that the <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections">worker_connections</a> directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks (as limited by the <a href="#lua_max_running_timers">lua_max_running_timers</a> directive).</p><p>A lot of the Lua APIs for Nginx are enabled in the context of the timer callbacks, like stream/datagram cosockets (<a href="#ngxsockettcp">ngx.socket.tcp</a> and <a href="#ngxsocketudp">ngx.socket.udp</a>), shared memory dictionaries (<a href="#ngxshareddict">ngx.shared.DICT</a>), user coroutines (<a href="#coroutinecreate">coroutine.*</a>), user "light threads" (<a href="#ngxthreadspawn">ngx.thread.*</a>), <a href="#ngxexit">ngx.exit</a>, <a href="#ngxnow">ngx.now</a>/<a href="#ngxtime">ngx.time</a>, <a href="#ngxmd5">ngx.md5</a>/<a href="#ngxsha1_bin">ngx.sha1_bin</a>, are all allowed. But the subrequest API (like <a href="#ngxlocationcapture">ngx.location.capture</a>), the <a href="#ngxreqstart_time">ngx.req.*</a> API, the downstream output API (like <a href="#ngxsay">ngx.say</a>, <a href="#ngxprint">ngx.print</a>, and <a href="#ngxflush">ngx.flush</a>) are explicitly disabled in this context.</p><p>You can pass most of the standard Lua values (nils, booleans, numbers, strings, tables, closures, file handles, and etc) into the timer callback, either explicitly as user arguments or implicitly as upvalues for the callback closure. There are several exceptions, however: you <em>cannot</em> pass any thread objects returned by <a href="#coroutinecreate">coroutine.create</a> and <a href="#ngxthreadspawn">ngx.thread.spawn</a> or any cosocket objects returned by <a href="#ngxsockettcp">ngx.socket.tcp</a>, <a href="#ngxsocketudp">ngx.socket.udp</a>, and <a href="#ngxreqsocket">ngx.req.socket</a> because these objects' lifetime is bound to the request context creating them while the timer callback is detached from the creating request's context (by design) and runs in its own (fake) request context. If you try to share the thread or cosocket objects across the boundary of the creating request, then you will get the "no co ctx found" error (for threads) or "bad request" (for cosockets). It is fine, however, to create all these objects inside your timer callback.</p><p>This API was first introduced in the <code>v0.8.0</code> release.</p>