<p><strong>syntax:</strong> <em>res = ngx.location.capture(uri, options?)</em></p><p><strong>context:</strong> <em>rewrite_by_lua&#42;, access_by_lua&#42;, content_by_lua&#42;</em></p><p>Issues a synchronous but still non-blocking <em>Nginx Subrequest</em> using <code>uri</code>.</p><p>Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or <em>any</em> other nginx C modules like <code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>, <code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even ngx_lua itself and etc etc etc.</p><p>Also note that subrequests just mimic the HTTP interface but there is <em>no</em> extra HTTP/TCP traffic <em>nor</em> IPC involved. Everything works internally, efficiently, on the C level.</p><p>Subrequests are completely different from HTTP 301/302 redirection (via <a href="#ngxredirect">ngx.redirect</a>) and internal redirection (via <a href="#ngxexec">ngx.exec</a>).</p><p>You should always read the request body (by either calling <a href="#ngxreqread_body">ngx.req.read_body</a> or configuring <a href="#lua_need_request_body">lua_need_request_body</a> on) before initiating a subrequest.</p><p>This API function (as well as <a href="#ngxlocationcapture_multi">ngx.location.capture_multi</a>) always buffers the whole response body of the subrequest in memory. Thus, you should use <a href="#ngxsockettcp">cosockets</a> and streaming processing instead if you have to handle large subrequest responses.</p><p>Here is a basic example:</p><p>```lua</p><p>res = ngx.location.capture(uri) ```</p><p>Returns a Lua table with 4 slots: <code>res.status</code>, <code>res.header</code>, <code>res.body</code>, and <code>res.truncated</code>.</p><p><code>res.status</code> holds the response status code for the subrequest response.</p><p><code>res.header</code> holds all the response headers of the subrequest and it is a normal Lua table. For multi-value response headers, the value is a Lua (array) table that holds all the values in the order that they appear. For instance, if the subrequest response headers contain the following lines:</p><p>```bash</p><p>Set-Cookie: a=3  Set-Cookie: foo=bar  Set-Cookie: baz=blah ```</p><p>Then <code>res.header[&quot;Set-Cookie&quot;]</code> will be evaluated to the table value <code>{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}</code>.</p><p><code>res.body</code> holds the subrequest's response body data, which might be truncated. You always need to check the <code>res.truncated</code> boolean flag to see if <code>res.body</code> contains truncated data. The data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote.</p><p>URI query strings can be concatenated to URI itself, for instance,</p><p>```lua</p><p>res = ngx.location.capture('/foo/bar?a=3&amp;b=4') ```</p><p>Named locations like <code>@foo</code> are not allowed due to a limitation in the nginx core. Use normal locations combined with the <code>internal</code> directive to prepare internal-only locations.</p><p>An optional option table can be fed as the second argument, which supports the options:</p>
<ul>
  <li><code>method</code> specify the subrequest's request method, which only accepts constants like <code>ngx.HTTP_POST</code>.</li>
  <li><code>body</code> specify the subrequest's request body (string value only).</li>
  <li><code>args</code> specify the subrequest's URI query arguments (both string value and Lua tables are accepted)</li>
  <li><code>ctx</code> specify a Lua table to be the <a href="#ngxctx">ngx.ctx</a> table for the subrequest. It can be the current request's <a href="#ngxctx">ngx.ctx</a> table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the <code>v0.3.1rc25</code> release.</li>
  <li><code>vars</code> take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value. This option was first introduced in the <code>v0.3.1rc31</code> release.</li>
  <li><code>copy_all_vars</code> specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the <code>v0.3.1rc31</code> release.</li>
  <li><code>share_all_vars</code> specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request. Enabling this option may lead to hard-to-debug issues due to bad side-effects and is considered bad and harmful. Only enable this option when you completely know what you are doing.</li>
  <li><code>always_forward_body</code> when set to true, the current (parent) request's request body will always be forwarded to the subrequest being created if the <code>body</code> option is not specified. The request body read by either <a href="#ngxreqread_body">ngx.req.read_body()</a> or <a href="#lua_need_request_body">lua_need_request_body on</a> will be directly forwarded to the subrequest without copying the whole request body data when creating the subrequest (no matter the request body data is buffered in memory buffers or temporary files). By default, this option is <code>false</code> and when the <code>body</code> option is not specified, the request body of the current (parent) request is only forwarded when the subrequest takes the <code>PUT</code> or <code>POST</code> request method.</li>
</ul><p>Issuing a POST subrequest, for example, can be done as follows</p><p>```lua</p><p>res = ngx.location.capture(  '/foo/bar',  { method = ngx.HTTP_POST, body = 'hello, world' }  ) ```</p><p>See HTTP method constants methods other than POST. The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.</p><p>The <code>args</code> option can specify extra URI arguments, for instance,</p><p>```lua</p><p>ngx.location.capture('/foo?a=1',  { args = { b = 3, c = ':' } }  ) ```</p><p>is equivalent to</p><p>```lua</p><p>ngx.location.capture('/foo?a=1&amp;b=3&amp;c=%3a') ```</p><p>that is, this method will escape argument keys and values according to URI rules and concatenate them together into a complete query string. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the <a href="#ngxencode_args">ngx.encode_args</a> method.</p><p>The <code>args</code> option can also take plain query strings:</p><p>```lua</p><p>ngx.location.capture('/foo?a=1',  { args = 'b=3&amp;c=%3a' } }  ) ```</p><p>This is functionally identical to the previous examples.</p><p>The <code>share_all_vars</code> option controls whether to share nginx variables among the current request and its subrequests. If this option is set to <code>true</code>, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.</p><p>Care should be taken in using this option as variable scope sharing can have unexpected side effects. The <code>args</code>, <code>vars</code>, or <code>copy_all_vars</code> options are generally preferable instead.</p><p>This option is set to <code>false</code> by default</p><p>```nginx</p><p>location /other {  set $dog "$dog world";  echo "$uri dog: $dog";  }</p><p>location /lua {  set $dog 'hello';  content_by_lua_block {  res = ngx.location.capture("/other",  { share_all_vars = true });</p>
<pre><code>     ngx.print(res.body)
     ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)
 }
</code></pre><p>} ```</p><p>Accessing location <code>/lua</code> gives</p>
<pre><code>/other dog: hello world
/lua: hello world
</code></pre><p>The <code>copy_all_vars</code> option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.</p><p>```nginx</p><p>location /other {  set $dog "$dog world";  echo "$uri dog: $dog";  }</p><p>location /lua {  set $dog 'hello';  content_by_lua_block {  res = ngx.location.capture("/other",  { copy_all_vars = true });</p>
<pre><code>     ngx.print(res.body)
     ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)
 }
</code></pre><p>} ```</p><p>Request <code>GET /lua</code> will give the output</p>
<pre><code>/other dog: hello world
/lua: hello
</code></pre><p>Note that if both <code>share_all_vars</code> and <code>copy_all_vars</code> are set to true, then <code>share_all_vars</code> takes precedence.</p><p>In addition to the two settings above, it is possible to specify values for variables in the subrequest using the <code>vars</code> option. These variables are set after the sharing or copying of variables has been evaluated, and provides a more efficient method of passing specific values to a subrequest over encoding them as URL arguments and unescaping them in the Nginx config file.</p><p>```nginx</p><p>location /other {  content_by_lua_block {  ngx.say("dog = ", ngx.var.dog)  ngx.say("cat = ", ngx.var.cat)  }  }</p><p>location /lua {  set $dog '';  set $cat '';  content_by_lua_block {  res = ngx.location.capture("/other",  { vars = { dog = "hello", cat = 32 }});</p>
<pre><code>     ngx.print(res.body)
 }
</code></pre><p>} ```</p><p>Accessing <code>/lua</code> will yield the output</p>
<pre><code>dog = hello
cat = 32
</code></pre><p>The <code>ctx</code> option can be used to specify a custom Lua table to serve as the <a href="#ngxctx">ngx.ctx</a> table for the subrequest.</p><p>```nginx</p><p>location /sub {  content_by_lua_block {  ngx.ctx.foo = "bar";  }  }  location /lua {  content_by_lua_block {  local ctx = {}  res = ngx.location.capture("/sub", { ctx = ctx })</p>
<pre><code>     ngx.say(ctx.foo);
     ngx.say(ngx.ctx.foo);
 }
</code></pre><p>} ```</p><p>Then request <code>GET /lua</code> gives</p>
<pre><code>bar
nil
</code></pre><p>It is also possible to use this <code>ctx</code> option to share the same <a href="#ngxctx">ngx.ctx</a> table between the current (parent) request and the subrequest:</p><p>```nginx</p><p>location /sub {  content_by_lua_block {  ngx.ctx.foo = "bar";  }  }  location /lua {  content_by_lua_block {  res = ngx.location.capture("/sub", { ctx = ngx.ctx })  ngx.say(ngx.ctx.foo);  }  } ```</p><p>Request <code>GET /lua</code> yields the output</p>
<pre><code>bar
</code></pre><p>Note that subrequests issued by <a href="#ngxlocationcapture">ngx.location.capture</a> inherit all the request headers of the current request by default and that this may have unexpected side effects on the subrequest responses. For example, when using the standard <code>ngx_proxy</code> module to serve subrequests, an "Accept-Encoding: gzip" header in the main request may result in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers">proxy_pass_request_headers</a> to <code>off</code> in subrequest locations.</p><p>When the <code>body</code> option is not specified and the <code>always_forward_body</code> option is false (the default value), the <code>POST</code> and <code>PUT</code> subrequests will inherit the request bodies of the parent request (if any).</p><p>There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was <code>50</code> concurrent subrequests and in more recent versions, Nginx <code>1.1.x</code> onwards, this was increased to <code>200</code> concurrent subrequests. When this limit is exceeded, the following error message is added to the <code>error.log</code> file:</p>
<pre><code>[error] 13983#0: *1 subrequests cycle while processing &quot;/uri&quot;
</code></pre><p>The limit can be manually modified if required by editing the definition of the <code>NGX_HTTP_MAX_SUBREQUESTS</code> macro in the <code>nginx/src/http/ngx_http_request.h</code> file in the Nginx source tree.</p><p>Please also refer to restrictions on capturing locations configured by <a href="#locations-configured-by-subrequest-directives-of-other-modules">subrequest directives of other modules</a>.</p>