<p><strong>syntax:</strong> <em>val = ngx.arg[index]</em></p><p><strong>context:</strong> <em>set_by_lua&#42;, body_filter_by_lua&#42;</em></p><p>When this is used in the context of the <a href="#set_by_lua">set_by_lua</a> or <a href="#set_by_lua_file">set_by_lua_file</a> directives, this table is read-only and holds the input arguments to the config directives:</p><p>```lua</p><p>value = ngx.arg[n] ```</p><p>Here is an example</p><p>```nginx</p><p>location /foo {  set $a 32;  set $b 56;</p>
<pre><code> set_by_lua $sum
     &#39;return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])&#39;
     $a $b;

 echo $sum;
</code></pre><p>} ```</p><p>that writes out <code>88</code>, the sum of <code>32</code> and <code>56</code>.</p><p>When this table is used in the context of <a href="#body_filter_by_lua">body_filter_by_lua</a> or <a href="#body_filter_by_lua_file">body_filter_by_lua_file</a>, the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the "eof" flag indicating the end of the whole output data stream.</p><p>The data chunk and "eof" flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p>