<p><strong>context:</strong> <em>init_worker_by_lua&#42;, set_by_lua&#42;, rewrite_by_lua&#42;, access_by_lua&#42;, content_by_lua&#42;, header_filter_by_lua&#42;, body_filter_by_lua, log_by_lua&#42;, ngx.timer.&#42;, balancer_by_lua&#42;</em></p><p>This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables). </p><p>Consider the following example,</p><p>```nginx</p><p>location /test {  rewrite_by_lua '  ngx.ctx.foo = 76  ';  access_by_lua '  ngx.ctx.foo = ngx.ctx.foo + 3  ';  content_by_lua '  ngx.say(ngx.ctx.foo)  ';  } ```</p><p>Then <code>GET /test</code> will yield the output</p><p>```bash</p><p>79 ```</p><p>That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.</p><p>Every request, including subrequests, has its own copy of the table. For example:</p><p>```nginx</p><p>location /sub {  content_by_lua '  ngx.say("sub pre: ", ngx.ctx.blah)  ngx.ctx.blah = 32  ngx.say("sub post: ", ngx.ctx.blah)  ';  }</p><p>location /main {  content_by_lua '  ngx.ctx.blah = 73  ngx.say("main pre: ", ngx.ctx.blah)  local res = ngx.location.capture("/sub")  ngx.print(res.body)  ngx.say("main post: ", ngx.ctx.blah)  ';  } ```</p><p>Then <code>GET /main</code> will give the output</p><p>```bash</p><p>main pre: 73  sub pre: nil  sub post: 32  main post: 73 ```</p><p>Here, modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of <code>ngx.ctx.blah</code>.</p><p>Internal redirection will destroy the original request <code>ngx.ctx</code> data (if any) and the new request will have an empty <code>ngx.ctx</code> table. For instance,</p><p>```nginx</p><p>location /new {  content_by_lua '  ngx.say(ngx.ctx.foo)  ';  }</p><p>location /orig {  content_by_lua '  ngx.ctx.foo = "hello"  ngx.exec("/new")  ';  } ```</p><p>Then <code>GET /orig</code> will give</p><p>```bash</p><p>nil ```</p><p>rather than the original <code>&quot;hello&quot;</code> value.</p><p>Arbitrary data values, including Lua closures and nested tables, can be inserted into this "magic" table. It also allows the registration of custom meta methods.</p><p>Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,</p><p>```lua</p><p>ngx.ctx = { foo = 32, bar = 54 } ```</p><p>When being used in the context of <a href="#init_worker_by_lua">init_worker_by_lua*</a>, this table just has the same lifetime of the current Lua handler.</p><p>The <code>ngx.ctx</code> lookup requires relatively expensive metamethod calls and it is much slower than explicitly passing per-request data along by your own function arguments. So do not abuse this API for saving your own function arguments because it usually has quite some performance impact.</p><p>Because of the metamethod magic, never "local" the <code>ngx.ctx</code> table outside your Lua function scope on the Lua module level level due to <a href="#data-sharing-within-an-nginx-worker">worker-level data sharing</a>. For example, the following is bad:</p><p>```lua</p><p>-- mymodule.lua  local _M = {}</p><p>-- the following line is bad since ngx.ctx is a per-request  -- data while this <code>ctx</code> variable is on the Lua module level  -- and thus is per-nginx-worker.  local ctx = ngx.ctx</p><p>function _M.main()  ctx.foo = "bar"  end</p><p>return _M ```</p><p>Use the following instead:</p><p>```lua</p><p>-- mymodule.lua  local _M = {}</p><p>function _M.main(ctx)  ctx.foo = "bar"  end</p><p>return _M ```</p><p>That is, let the caller pass the <code>ctx</code> table explicitly via a function argument.</p>