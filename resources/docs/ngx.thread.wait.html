<p><strong>syntax:</strong> <em>ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)</em></p>
<p><strong>context:</strong> <em>rewrite_by_lua&#42;, access_by_lua&#42;, content_by_lua&#42;, ngx.timer.&#42;, ssl_certificate_by_lua&#42;, ssl_session_fetch_by_lua&#42;</em></p>
<p>Waits on one or more child "light threads" and returns the results of the first "light thread" that terminates (either successfully or with an error).</p>
<p>The arguments <code>thread1</code>, <code>thread2</code>, and etc are the Lua thread objects returned by earlier calls of <a href="#ngxthreadspawn">ngx.thread.spawn</a>.</p>
<p>The return values have exactly the same meaning as <a href="#coroutineresume">coroutine.resume</a>, that is, the first value returned is a boolean value indicating whether the "light thread" terminates successfully or not, and subsequent values returned are the return values of the user Lua function that was used to spawn the "light thread" (in case of success) or the error object (in case of failure).</p>
<p>Only the direct "parent coroutine" can wait on its child "light thread", otherwise a Lua exception will be raised.</p>
<p>The following example demonstrates the use of <code>ngx.thread.wait</code> and <a href="#ngxlocationcapture">ngx.location.capture</a> to emulate <a href="#ngxlocationcapture_multi">ngx.location.capture_multi</a>:</p>
<p>```lua</p>
<p>local capture = ngx.location.capture  local spawn = ngx.thread.spawn  local wait = ngx.thread.wait  local say = ngx.say</p>
<p>local function fetch(uri)  return capture(uri)  end</p>
<p>local threads = {  spawn(fetch, "/foo"),  spawn(fetch, "/bar"),  spawn(fetch, "/baz")  }</p>
<p>for i = 1, #threads do  local ok, res = wait(threads[i])  if not ok then  say(i, ": failed to run: ", res)  else  say(i, ": status: ", res.status)  say(i, ": body: ", res.body)  end  end</p>
<p>```</p>
<p>Here it essentially implements the "wait all" model.</p>
<p>And below is an example demonstrating the "wait any" model:</p>
<p>```lua</p>
<p>function f()  ngx.sleep(0.2)  ngx.say("f: hello")  return "f done"  end</p>
<p>function g()  ngx.sleep(0.1)  ngx.say("g: hello")  return "g done"  end</p>
<p>local tf, err = ngx.thread.spawn(f)  if not tf then  ngx.say("failed to spawn thread f: ", err)  return  end</p>
<p>ngx.say("f thread created: ", coroutine.status(tf))</p>
<p>local tg, err = ngx.thread.spawn(g)  if not tg then  ngx.say("failed to spawn thread g: ", err)  return  end</p>
<p>ngx.say("g thread created: ", coroutine.status(tg))</p>
<p>ok, res = ngx.thread.wait(tf, tg)  if not ok then  ngx.say("failed to wait: ", res)  return  end</p>
<p>ngx.say("res: ", res)</p>
<p>-- stop the "world", aborting other running threads  ngx.exit(ngx.OK) ```</p>
<p>And it will generate the following output:</p>
<pre><code>f thread created: running
g thread created: running
g: hello
res: g done
</code></pre>
<p>This API was first enabled in the <code>v0.7.0</code> release.</p>