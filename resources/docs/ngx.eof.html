<p><strong>syntax:</strong> <em>ok, err = ngx.eof()</em></p><p><strong>context:</strong> <em>rewrite_by_lua&#42;, access_by_lua&#42;, content_by_lua&#42;</em></p><p>Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the "last chunk".</p><p>When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on descent HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:</p><p>```nginx</p><p>location = /async {  keepalive_timeout 0;  content_by_lua '  ngx.say("got the task!")  ngx.eof() -- a descent HTTP client will close the connection at this point  -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...  ';  } ```</p><p>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a> will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort">proxy_ignore_client_abort</a> directive in your location block configured by <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>:</p><p>```nginx</p><p>proxy_ignore_client_abort on; ```</p><p>A better way to do background jobs is to use the <a href="#ngxtimerat">ngx.timer.at</a> API.</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p>