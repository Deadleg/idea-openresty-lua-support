<p><strong>syntax:</strong> <em>ok, err = ngx.flush(wait?)</em></p><p><strong>context:</strong> <em>rewrite_by_lua&#42;, access_by_lua&#42;, content_by_lua&#42;</em></p><p>Flushes response output to the client. </p><p><code>ngx.flush</code> accepts an optional boolean <code>wait</code> argument (Default: <code>false</code>) first introduced in the <code>v0.3.1rc34</code> release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the <code>wait</code> argument set to <code>true</code> switches to synchronous mode. </p><p>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout">send_timeout</a> setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</p><p>When <code>ngx.flush(true)</code> is called immediately after <a href="#ngxprint">ngx.print</a> or <a href="#ngxsay">ngx.say</a>, it causes the latter functions to run in synchronous mode. This can be particularly useful for streaming output.</p><p>Note that <code>ngx.flush</code> is not functional when in the HTTP 1.0 output buffering mode. See <a href="#http-10-support">HTTP 1.0 support</a>.</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p>