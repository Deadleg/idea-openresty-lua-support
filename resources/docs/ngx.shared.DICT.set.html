<p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> <em>init_by_lua&#42;, set_by_lua&#42;, rewrite_by_lua&#42;, access_by_lua&#42;, content_by_lua&#42;, header_filter_by_lua&#42;, body_filter_by_lua&#42;, log_by_lua&#42;, ngx.timer.&#42;, balancer_by_lua&#42;, ssl_certificate_by_lua&#42;, ssl_session_fetch_by_lua&#42;, ssl_session_store_by_lua&#42;</em></p><p>Unconditionally sets a key-value pair into the shm-based dictionary <a href="#ngxshareddict">ngx.shared.DICT</a>. Returns three values:</p>
<ul>
  <li><code>success</code>: boolean value to indicate whether the key-value pair is stored or not.</li>
  <li><code>err</code>: textual error message, can be <code>&quot;no memory&quot;</code>.</li>
  <li><code>forcible</code>: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.</li>
</ul><p>The <code>value</code> argument inserted can be Lua booleans, numbers, strings, or <code>nil</code>. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the <a href="#ngxshareddictget">get</a> method.</p><p>The optional <code>exptime</code> argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is <code>0.001</code> seconds. If the <code>exptime</code> takes the value <code>0</code> (which is the default), then the item will never expire.</p><p>The optional <code>flags</code> argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to <code>0</code>. The user flags argument was first introduced in the <code>v0.5.0rc2</code> release.</p><p>When it fails to allocate memory for the current key-value item, then <code>set</code> will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by <a href="#lua_shared_dict">lua_shared_dict</a> or memory segmentation), then the <code>err</code> return value will be <code>no memory</code> and <code>success</code> will be <code>false</code>.</p><p>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.</p><p>The first argument to this method must be the dictionary object itself, for example,</p><p>```lua</p><p>local cats = ngx.shared.cats  local succ, err, forcible = cats.set(cats, "Marry", "it is a nice cat!") ```</p><p>or use Lua's syntactic sugar for method calls:</p><p>```lua</p><p>local cats = ngx.shared.cats  local succ, err, forcible = cats:set("Marry", "it is a nice cat!") ```</p><p>These two forms are fundamentally equivalent.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.</p><p>See also <a href="#ngxshareddict">ngx.shared.DICT</a>.</p>